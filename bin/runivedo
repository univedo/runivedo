#!/usr/bin/env ruby -KU

$: << File.dirname(__FILE__) + "/../lib"

require 'runivedo'
require 'rainbow'
require 'readline'
require 'readline/history/restore'
require 'terminal-table'
require 'optparse'

def pluralize(singular, count)
  "#{count} #{singular}#{count != 1 ? 's' : ''}"
end

HIST_FILE = "#{ENV["HOME"]}/.runivedo_history"
Readline::History::Restore.new(HIST_FILE)

def readline_wrapper
  line = Readline.readline('â†’ '.color(:blue).bright, true)
  return nil if line.nil?
  if line =~ /^\s*$/ or Readline::HISTORY.to_a[-2] == line
    Readline::HISTORY.pop
  end
  line
end

# Completion
COMPLETION = [
  "add", "aid", "alter", "and", "as", "assign", "avg", "begin", "binaryCond",
  "by", "check", "column", "combine", "commit", "constraint", "count", "create",
  "cross", "delete", "distinct", "drop", "except", "fields", "file", "for",
  "from", "full", "function", "group", "having", "ilike", "in", "inner",
  "insert","into", "is", "join", "jtype", "left", "lift", "like", "max", "min",
  "natural", "not", "not null", "null", "of", "on", "operator", "or", "order",
  "primary key", "query", "release", "res", "right", "rollback", "savepoint",
  "select", "set", "share", "sum", "table", "to", "transaction", "unique",
  "update", "using", "value", "values", "where"
].sort.map(&:upcase)
comp = proc { |s| COMPLETION.grep(/^#{Regexp.escape(s)}/i) }
Readline.completion_append_character = " "
Readline.completion_proc = comp

options = {}
op = OptionParser.new do |opts|
  opts.banner = "Usage: runivedo [options] <url>"
  options[:user] = "test"
  opts.on('-u', '--user USER', "Username (default 'test')") { |user| options[:user] = user }
  options[:password] = ""
  opts.on('-p', '--password PASSWORD', "Password (default '')") { |password| options[:password] = password }
  options[:uts] = "app.uts"
  opts.on('-f', '--uts UTS', "UTS file (default 'app.uts')") { |uts| options[:uts] = uts }
  opts.on('-v', "--version", "Show version") do
    puts "Runivedo #{Runivedo::VERSION}"
    exit
  end
  opts.on('-h', '--help', 'Display this screen') do
    puts opts
    exit
  end
end
op.parse!

if ARGV.count == 0
  puts op
  exit
end
options[:url] = ARGV[0]
begin
  options[:uts] = IO.read(options[:uts])
rescue
  puts "Could not read #{options[:uts]}, continuing without.".color(:yellow)
  options[:uts] = ""
end

runivedo = Runivedo::Runivedo.new(options)
puts "Connected."

while line = readline_wrapper
  break if line.nil?
  line.strip!
  next if line.empty?
  case line
  when "q", "quit", "exit"
    break
  when "version", "info", "v"
    puts "Runivedo Shell #{Runivedo::VERSION}"
    puts "(c) 2013 Univedo"
  when "help", "h", "?"
    puts "Runivedo Shell #{Runivedo::VERSION} Help"
    puts "TODO"
  else
    begin
      result = runivedo.execute(line)
      arr = result.rows
      if arr.count > 0
        col_count = arr[0].count
        puts Terminal::Table.new rows: arr, headings: (1..col_count).collect { |i| "Col #{i}".bright }
        puts "#{pluralize("row", arr.count)} affected.".color(:green)
      end
      puts "#{pluralize("row", result.affected_rows)} affected.".color(:green)
    rescue => e
      puts "Caught exception:"
      puts e.to_s.color(:red)
      puts e.backtrace
    end
  end
end

puts
puts "Bye"
